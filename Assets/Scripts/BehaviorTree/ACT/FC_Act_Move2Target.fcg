import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Scene.fcc" as Scene
import "BehaviourTree.fcc" as BehaviourTree
import "Playable.fcc" as Playable
import "Animation.fcc" as Animation
import "Physics.fcc" as Physics
import "List.fcc" as List
import "Math.fcc" as Math
import "../../MobScripts/FC_NormalZombie.fcg" as mobScript
import "../../Static/FC_Utilities.fcg" as PVEUtilities

graph FC_Act_Move2Target {
    //Executed when entity is created
    Dist float = 0
	IsPathFinding bool = false
	KeepDist float = 0
	Mover entity<FrameSelfRelative> = nil
	PathList List<Vector3> = List<Vector3>{}
	LastFindPathTime float = 0
	TargetPos Vector3 = Vector3{0,0,0}
	Speed float = 0
	LastTickTime int = 0
	CurNodeIndex int = 0

	//funcID: FindPath
	async func myFindPath(startPos Vector3, endPos Vector3) {
		IsPathFinding = true
		FindPath(startPos, endPos, out var isSuccess3, out var pathPoints4)
		IsPathFinding = false
		if (pathPoints4 != nil) {
			PathList = pathPoints4
			CurNodeIndex = 0
		}
	}

	//funcID: PlayAction
	func PlayAction(owner entity<BevTreeAttachable>) BTreeNodeState {
       // LogInfo("PlayAction")
        var curTarget entity<Player> = owner<Mob>.CurrTarget
		if (curTarget == nil) {
			PlayAnimation(owner as entity<AnimationControllerAttachable>, "Idle", 1, LoopType.Once)
			return BevTreeNodeStatus.Finish
		}
		var gameTime int = globalEntity<Global>.GameTimeCount
		var timeDiff int = (gameTime - LastTickTime)
		LastTickTime = gameTime
		SingleRaycast((curTarget<Player>.Position+ Vector3{0,0.5,0}), Vector3{0,-1,0}, 5, List<int>{}, false, out var hitEntities9, out var hitPoints10, out var hitDistances11, out var hitNormals12)
		TargetPos = hitPoints10
		var lastPos Vector3 = owner<Transform>.Position
		if ((gameTime - LastFindPathTime) > 1000) {
			LastFindPathTime = gameTime
			start myFindPath(lastPos, TargetPos)
		}
		if IsPathFinding {
			return BevTreeNodeStatus.Running
		}
		if (Length(PathList) <= CurNodeIndex) {
			PlayAnimation(owner as entity<AnimationControllerAttachable>, "Idle", 1, LoopType.Once)
			return BevTreeNodeStatus.Finish
		}
		TargetPos = PathList[CurNodeIndex]
		var isLast bool = (Length(PathList) == (CurNodeIndex + 1))
		var sub Vector3 = TargetPos - lastPos
		var normalizeDir Vector3 = Normalize(sub)
		Dist = Magnitude(sub)
		if isLast {
			if (Dist <= KeepDist) {
				PlayAnimation(owner as entity<AnimationControllerAttachable>, "Idle", 1, LoopType.Once)
				return BevTreeNodeStatus.Finish
			}
			Dist = (Dist - KeepDist)
			TargetPos = (lastPos+normalizeDir*Dist)
		}
		var deltaPos Vector3 = normalizeDir*Speed*(0.001*timeDiff)
		PVEUtilities.myLookAt(owner<Transform>, curTarget, TargetPos)
		
		if (Dist <= Magnitude(deltaPos)) {
			owner<mobScript>.CreateMoveTween(owner<Transform>.Position, TargetPos)
			if isLast {
				PlayAnimation(owner as entity<AnimationControllerAttachable>, "Idle", 1, LoopType.Once)
				return BevTreeNodeStatus.Finish
			} else {
				CurNodeIndex = (CurNodeIndex + 1)
				return BevTreeNodeStatus.Running
			}
		} else {
			owner<mobScript>.CreateMoveTween(owner<Transform>.Position, (lastPos+deltaPos))
			return BevTreeNodeStatus.Running
		}
	}

	//eventID: 18//s8004_dup_block
	event OnNodeEnter(nodeName string, owner entity<BevTreeAttachable>) {
		Speed = owner<Mob>.WalkSpeed
		LastTickTime = globalEntity<Global>.GameTimeCount
		GetNodeVariable(thisEntity as entity<BevTreeCustomNode>, "KeepDist", out var keepDist)
		KeepDist = keepDist as float
      
		PlayAnimation(owner as entity<AnimationControllerAttachable>, "Walk", 1, LoopType.Once)
		


		// if (owner<Mob>.ZombieInfo["MoveSpeedScale"] == owner<Mob>.MoveSpeedDic["Run"]) {
		// 	PlayAnimation(owner as entity<AnimationControllerAttachable>, Connect(owner<Mob>.ZombieName, "_Run"), 1, LoopType.Once)
		// } else if (owner<Mob>.ZombieInfo["MoveSpeedScale"] == owner<Mob>.MoveSpeedDic["Walk"]) {
		// 	PlayAnimation(owner as entity<AnimationControllerAttachable>, Connect(owner<Mob>.ZombieName, "_Walk"), 1, LoopType.Once)
		// } else {
		// 	PlayAnimation(owner as entity<AnimationControllerAttachable>, Connect(owner<Mob>.ZombieName, "_Wander"), 1, LoopType.Once)
		// }
		LastFindPathTime = 0
		CurNodeIndex = 0
	}
}